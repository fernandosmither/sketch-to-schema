import { Schema, DBType, Table, Column } from './types';

export const generateId = (): string => Math.random().toString(36).substr(2, 9);

export const generateSql = (schema: Schema, dbType: DBType): string => {
  let sql = `-- Generated by Sketch to Schema for ${dbType}\n\n`;

  // Helper to wrap identifiers
  const q = (name: string) => {
    if (dbType === DBType.POSTGRES) return `"${name}"`;
    if (dbType === DBType.MYSQL) return `\`${name}\``;
    return `"${name}"`;
  };

  schema.tables.forEach(table => {
    sql += `CREATE TABLE ${q(table.name)} (\n`;
    
    const lines: string[] = [];
    
    table.columns.forEach(col => {
      let line = `  ${q(col.name)} ${col.type}`;
      
      if (col.isPk && dbType === DBType.SQLITE && col.type === 'INTEGER') {
        line += ' PRIMARY KEY AUTOINCREMENT';
      } else {
        if (!col.isNullable) line += ' NOT NULL';
        if (col.isUnique) line += ' UNIQUE';
        // Note: Simple PK handling here. Composite PKs would need table-level constraints.
        if (col.isPk && dbType !== DBType.SQLITE) line += ' PRIMARY KEY';
      }
      lines.push(line);
    });

    // Add Constraints for FKs (if defined within table context, but we might do ALTER TABLE later for cleaner cyclic deps)
    // For simplicity in this tool, we'll list them inline if possible, or add at end.
    // Let's stick to simple inline for now or ALTER statements at the end.
    
    sql += lines.join(',\n');
    sql += `\n);\n\n`;
  });

  if (schema.relationships.length > 0) {
    sql += `-- Relationships\n`;
    schema.relationships.forEach(rel => {
      const fromTable = schema.tables.find(t => t.id === rel.fromTableId);
      const toTable = schema.tables.find(t => t.id === rel.toTableId);
      const fromCol = fromTable?.columns.find(c => c.id === rel.fromColumnId);
      const toCol = toTable?.columns.find(c => c.id === rel.toColumnId);

      if (fromTable && toTable && fromCol && toCol) {
         sql += `ALTER TABLE ${q(fromTable.name)} ADD CONSTRAINT ${q(`fk_${fromTable.name}_${fromCol.name}`)} FOREIGN KEY (${q(fromCol.name)}) REFERENCES ${q(toTable.name)}(${q(toCol.name)});\n`;
      }
    });
  }

  return sql;
};

// Initial layout algorithm
export const layoutTables = (tables: any[]): Table[] => {
  const GRID_SIZE = 3; // 3 columns
  const SPACING_X = 350;
  const SPACING_Y = 300;
  
  return tables.map((t, index) => ({
    ...t,
    id: t.id || generateId(),
    columns: t.columns.map((c: any) => ({ ...c, id: c.id || generateId() })),
    position: {
      x: 50 + (index % GRID_SIZE) * SPACING_X,
      y: 50 + Math.floor(index / GRID_SIZE) * SPACING_Y
    }
  }));
};
